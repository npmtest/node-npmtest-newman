{"/home/travis/build/npmtest/node-npmtest-newman/test.js":"/* istanbul instrument in package npmtest_newman */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-newman/lib.npmtest_newman.js":"/* istanbul instrument in package npmtest_newman */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_newman = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_newman = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-newman/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-newman && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_newman */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_newman\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_newman.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_newman.rollup.js'] =\n            local.assetsDict['/assets.npmtest_newman.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_newman.__dirname +\n                    '/lib.npmtest_newman.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-newman/node_modules/newman/index.js":"/**!\n * @license Copyright 2016 Postdot Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and limitations under the License.\n */\nmodule.exports = require('./lib');\n","/home/travis/build/npmtest/node-npmtest-newman/node_modules/newman/lib/index.js":"module.exports = {\n    run: require('./run'),\n    version: require('./version')\n};\n","/home/travis/build/npmtest/node-npmtest-newman/node_modules/newman/lib/run/index.js":"var fs = require('fs'),\n    _ = require('lodash'),\n    sdk = require('postman-collection'),\n    asyncEach = require('async/each'),\n    EventEmitter = require('eventemitter3'),\n    runtime = require('postman-runtime'),\n    util = require('../util'),\n    exportFile = require('./export-file'),\n    RunSummary = require('./summary'),\n    getOptions = require('./options'),\n    request = require('postman-request'),\n\n    /**\n     * This object describes the various events raised by Newman, and what each event argument contains.\n     * Error and cursor are present in all events.\n     *\n     * @type {Object}\n     */\n    runtimeEvents = {\n        start: [],\n        beforeIteration: [],\n        beforeItem: ['item'],\n        beforePrerequest: ['events', 'item'],\n        prerequest: ['executions', 'item'],\n        beforeRequest: ['request', 'item'],\n        request: ['response', 'request', 'item'],\n        beforeTest: ['events', 'item'],\n        test: ['executions', 'item'],\n        item: ['item'],\n        iteration: [],\n        beforeScript: ['script', 'event', 'item'],\n        script: ['execution', 'script', 'event', 'item']\n    },\n\n    /**\n     * load all the default reporters here. if you have new reporter, add it to this list\n     * we know someone, who does not like dynamic requires\n     *\n     * @type {Object}\n     */\n    defaultReporters = {\n        cli: require('../reporters/cli'),\n        json: require('../reporters/json'),\n        html: require('../reporters/html'),\n        junit: require('../reporters/junit'),\n        progress: require('../reporters/progress'),\n        emojitrain: require('../reporters/emojitrain')\n    };\n\n/**\n * Runs the collection, with all the provided options, returning an EventEmitter.\n *\n * @param {Object} options - The set of wrapped options, passed by the CLI parser.\n * @param {Collection|Object|String} options.collection - A JSON / Collection / String representing the collection.\n * @param {Object|String} options.environment - An environment JSON / file path for the current collection run.\n * @param {Object|String} options.globals - A globals JSON / file path for the current collection run.\n * @param {Object|String} options.iterationData - An iterationDate JSON / file path for the current collection run.\n * @param {Object|String} options.reporters - A set of reporter names and their associated options for the current run.\n * @param {String} options.exportGlobals - The relative path to export the globals file from the current run to.\n * @param {String} options.exportEnvironment - The relative path to export the environment file from the current run to.\n * @param {String} options.exportCollection - The relative path to export the collection from the current run to.\n * @param {Function} callback - The callback function invoked to mark the end of the collection run.\n * @returns {EventEmitter} - An EventEmitter instance with done and error event attachments.\n */\nmodule.exports = function (options, callback) {\n    // validate all options. it is to be noted that `options` parameter is option and is polymorphic\n    (!callback && _.isFunction(options)) && (\n        (callback = options),\n        (options = {})\n    );\n    !_.isFunction(callback) && (callback = _.noop);\n\n    var emitter = new EventEmitter(), // @todo: create a new inherited constructor\n        runner = new runtime.Runner();\n\n    // get the configuration from various sources\n    getOptions(options, function (err, options) {\n        if (err) {\n            return callback(err);\n        }\n\n        // ensure that the collection option is present before starting a run\n        if (!_.isObject(options.collection)) {\n            return callback(new Error('newman: expecting a collection to run'));\n        }\n\n        // store summary object and other relevant information inside the emitter\n        emitter.summary = new RunSummary(emitter, options);\n\n        // to store the exported content from reporters\n        emitter.exports = [];\n\n        // now start the run!\n        runner.run(options.collection, {\n            stopOnFailure: options.bail, // LOL, you just got trolled ¯\\_(ツ)_/¯\n            abortOnFailure: options.abortOnFailure, // used in integration tests, to be considered for a future release\n            iterationCount: options.iterationCount,\n            environment: options.environment,\n            globals: options.globals,\n            entrypoint: options.folder,\n            data: options.iterationData,\n            delay: {\n                item: options.delayRequest\n            },\n            // todo: add support for more types of timeouts, currently only request is supported\n            timeout: options.timeoutRequest ? { request: options.timeoutRequest } : undefined,\n            fileResolver: fs,\n            requester: {\n                cookieJar: request.jar(),\n                followRedirects: _.has(options, 'ignoreRedirects') ? !options.ignoreRedirects : undefined,\n                strictSSL: _.has(options, 'insecure') ? !options.insecure : undefined\n            },\n            certificates: options.sslClientCert && new sdk.CertificateList({}, [{\n                name: 'client-cert',\n                matches: [sdk.UrlMatchPattern.MATCH_ALL_URLS],\n                key: { src: options.sslClientKey },\n                cert: { src: options.sslClientCert },\n                passphrase: options.sslClientPassphrase\n            }])\n        }, function (err, run) {\n            var callbacks = {},\n                // ensure that the reporter option type polymorphism is handled\n                reporters = _.isString(options.reporters) ? [options.reporters] : options.reporters;\n\n            // emit events for all the callbacks triggered by the runtime\n            _.forEach(runtimeEvents, function (definition, eventName) {\n                // intercept each runtime.* callback and expose a global object based event\n                callbacks[eventName] = function (err, cursor) {\n                    var args = arguments,\n                        obj = { cursor: cursor };\n\n                    // convert the arguments into an object by taking the key name reference from the definition\n                    // object\n                    _.forEach(definition, function (key, index) {\n                        obj[key] = args[index + 2]; // first two are err, cursor\n                    });\n\n                    args = [eventName, err, obj];\n                    emitter.emit.apply(emitter, args); // eslint-disable-line prefer-spread\n                };\n            });\n\n            // add non generic callback handling\n            _.assignIn(callbacks, {\n\n                /**\n                 * Bubbles up console messages.\n                 *\n                 * @param {Object} cursor - The run cursor instance.\n                 * @param {String} level - The level of console logging [error, silent, etc].\n                 * @returns {*}\n                 */\n                console: function (cursor, level) {\n                    emitter.emit('console', null, {\n                        cursor: cursor,\n                        level: level,\n                        messages: _.slice(arguments, 2)\n                    });\n                },\n\n                /**\n                 * The exception handler for the current run instance.\n                 *\n                 * @todo Fix bug of arg order in runtime.\n                 * @param {Object} cursor - The run cursor.\n                 * @param {?Error} err - An Error instance / null object.\n                 * @returns {*}\n                 */\n                exception: function (cursor, err) {\n                    emitter.emit('exception', null, {\n                        cursor: cursor,\n                        error: err\n                    });\n                },\n\n                /**\n                 * Custom callback to override the `done` event to fire the end callback.\n                 *\n                 * @todo Do some memory cleanup here?\n                 * @param {?Error} err - An error instance / null passed from the done event handler.\n                 * @param {Object} cursor - The run instance cursor.\n                 * @returns {*}\n                 */\n                done: function (err, cursor) {\n                    // in case runtime faced an error during run, we do not process any other event and emit `done`.\n                    // we do it this way since, an error in `done` callback would have anyway skipped any intermediate\n                    // events or callbacks\n                    if (err) {\n                        emitter.emit('done', err, emitter.summary);\n                        callback(err, emitter.summary);\n                        return;\n                    }\n\n                    // we emit a `beforeDone` event so that reporters and other such addons can do computation before\n                    // the run is marked as done\n                    emitter.emit('beforeDone', null, {\n                        cursor: cursor,\n                        summary: emitter.summary\n                    });\n\n                    _.forEach(['environment', 'globals', 'collection'], function (item) {\n                        // fetch the path name from options if one is provided\n                        var path = _.get(options, _.camelCase(`export-${item}`));\n\n                        // if the options have an export path, then add the item to export queue\n                        path && emitter.exports.push({\n                            name: item,\n                            default: `newman-${item}.json`,\n                            path: path,\n                            content: _.merge(emitter.summary[item].toJSON(), {\n                                _postman_variable_scope: item,\n                                _postman_exported_at: (new Date()).toISOString(),\n                                _postman_exported_using: util.userAgent\n                            })\n                        });\n                    });\n\n                    asyncEach(emitter.exports, exportFile, function (err) {\n                        // we now trigger actual done event which we had overridden\n                        emitter.emit('done', err, emitter.summary);\n                        callback(err, emitter.summary);\n                    });\n                }\n            });\n\n            // generate pseudo assertion events since runtime does not trigger assertion events yet.\n            // without this, all reporters would needlessly need to extract assertions and create an error object\n            // out of it\n            emitter.on('script', function (err, o) {\n                // we iterate on each test assertion to trigger an event. during this, we create a pseudo error object\n                // for the assertion\n                var index = 0,\n                    type = o && o.event && o.event.listen;\n\n                _.forEach(_.get(o.execution, 'globals.tests'), function (passed, assertion) {\n                    emitter.emit('assertion', (passed ? null : {\n                        name: 'AssertionFailure',\n                        index: index,\n                        message: assertion,\n\n                        stack: 'AssertionFailure: Expected tests[\"' + assertion + '\"] to be truth-like\\n' +\n                            '   at Object.eval test.js:' + (index + 1) + ':' +\n                            ((o.cursor && o.cursor.position || 0) + 1) + ')'\n                    }), _.assignIn({ assertion: assertion }, o));\n                    index += 1;\n                });\n\n                // bubble special script name based events\n                type && emitter.emit(type + 'Script', err, o);\n            });\n\n            emitter.on('beforeScript', function (err, o) {\n                // bubble special script name based events\n                o && o.event && o.event && emitter.emit(_.camelCase('before-' + o.event.listen + 'Script'), err, o);\n            });\n\n            // initialise all the reporters\n            !emitter.reporters && (emitter.reporters = {});\n            _.isArray(reporters) && _.forEach(reporters, function (reporterName) {\n                // disallow duplicate reporter initialisation\n                if (_.has(emitter.reporters, reporterName)) { return; }\n\n                var Reporter = defaultReporters[reporterName];\n\n                // check if the reporter is not a local reporter, then load an external reporter\n                if (!Reporter) {\n                    try {\n                        Reporter = require((function (name) { // ensure scoped packages are loaded\n                            var prefix = '',\n                                scope = (name.charAt(0) === '@') && name.substr(0, name.indexOf('/') + 1);\n\n                            if (scope) {\n                                prefix = scope;\n                                name = name.substr(scope.length);\n                            }\n\n                            return prefix + 'newman-reporter-' + name;\n                        }(reporterName)));\n                    }\n                    // we suppress this error since, the check of missing error is done later\n                    // @todo - maybe have a debug mode and log error there\n                    catch (error) { } // eslint-disable-line no-empty\n                }\n\n                try {\n                    // we could have checked _.isFunction(Reporter), here, but we do not do that so that the nature of\n                    // reporter error can be bubbled up\n                    Reporter && (emitter.reporters[reporterName] = new Reporter(emitter,\n                        _.get(options, 'reporter.' + reporterName, {}), options));\n                }\n                catch (error) {\n                    // if the reporter errored out during initialisation, we should not stop the run simply log\n                    // the error stack trace for debugging\n                    // @todo: route this via print module to respect silent flags\n                    console.warn(error);\n                }\n\n                // if the reporter is not loaded then we need to warn users\n                if (!(_.isFunction(Reporter) && _.isObject(emitter.reporters[reporterName]))) {\n                    // @todo: route this via print module to respect silent flags\n                    console.warn(`newman warning: \"${reporterName}\" reporter could not be loaded.`);\n                }\n            });\n\n            // raise warning when more than one dominant reporters are used\n            (function (reporters) {\n                // find all reporters whose `dominant` key is set to true\n                var conflicts = _.keys(_.transform(reporters, function (conflicts, reporter, name) {\n                    reporter.dominant && (conflicts[name] = true);\n                }));\n\n                (conflicts.length > 1) && // if more than one dominant, raise a warning\n                    console.warn(`newman warning: ${conflicts.join(', ')} reporters might not work well together.`);\n            }(emitter.reporters));\n\n            // we ensure that everything is async to comply with event paradigm and start the run\n            setImmediate(function () {\n                run.start(callbacks);\n            });\n        });\n    });\n\n    return emitter;\n};\n","/home/travis/build/npmtest/node-npmtest-newman/node_modules/newman/lib/util.js":"var fs = require('fs'),\n\n    _ = require('lodash'),\n    prettyms = require('pretty-ms'),\n    filesize = require('filesize'),\n    request = require('postman-request'),\n    parseJson = require('parse-json'),\n\n    util,\n    version = require('../package.json').version,\n\n    SEP = ' / ',\n\n    /**\n     * The auxilliary character used to prettify file sizes from raw byte counts.\n     *\n     * @type {Object}\n     */\n    FILESIZE_OPTIONS = { spacer: '' },\n\n    USER_AGENT_VALUE = 'Newman/' + version;\n\nutil = {\n\n    /**\n     * The raw newman version, taken from package.json in the root directory\n     *\n     * @type {String}\n     */\n    version: version,\n\n    /**\n     * The user agent that this newman identifies as.\n     *\n     * @type {String}\n     */\n    userAgent: USER_AGENT_VALUE,\n\n    /**\n     * A utility helper method that prettifies and returns raw millisecond counts.\n     *\n     * @param {Number} ms - The raw millisecond count, usually from response times.\n     * @returns {String} - The pretified time, scaled to units of time, depending on the input value.\n     */\n    prettyms: function (ms) {\n        return (ms < 1998) ? `${parseInt(ms, 10)}ms` : prettyms(ms || 0);\n    },\n\n    /**\n     * A utility helper method to prettify byte counts into human readable strings.\n     *\n     * @param {Number} bytes - The raw byte count, usually from computed response sizes.\n     * @returns {String} - The prettified size, suffixed with scaled units, depending on the actual value provided.\n     */\n    filesize: function (bytes) {\n        return filesize(bytes || 0, FILESIZE_OPTIONS);\n    },\n\n    /**\n     * Resolves the fully qualified name for the provided item\n     *\n     * @param {PostmanItem|PostmanItemGroup} item The item for which to resolve the full name\n     * @param {?String} [separator=SEP] The separator symbol to join path name entries with\n     * @returns {String} The full name of the provided item, including prepended parent item names\n     * @private\n     */\n    getFullName: function (item, separator) {\n        if (_.isEmpty(item) || !_.isFunction(item.parent) || !_.isFunction(item.forEachParent)) { return; }\n\n        var chain = [];\n        item.forEachParent(function (parent) { chain.unshift(parent.name || parent.id); });\n\n        item.parent() && chain.push(item.name); // Add the current item only if it is not the collection instance\n        return chain.join(_.isString(separator) ? separator : SEP);\n    },\n\n    /**\n     * Loads JSON data from the given location.\n     *\n     * @param {String} location - Can be an HTTP URL or a local file path.\n     * @param {Object=} options - A set of options for JSON data loading.\n     * @param {Object} options.apikey - Postman's cloud API Key (if the resource is being loaded from Postman Cloud).\n     * @param {Function} callback - The function whose invocation marks the end of the JSON fetch routine.\n     * @returns {*}\n     */\n    fetchJson: function (location, options, callback) {\n        !callback && _.isFunction(options) && (callback = options, options = {});\n        return (/^https?:\\/\\/.*/).test(location) ?\n            // Load from URL\n            request.get({\n                url: location,\n                json: true,\n                headers: { 'User-Agent': USER_AGENT_VALUE }\n            }, (err, response, body) => {\n                if (err) {\n                    return callback(_.set(err, 'help', `unable to fetch data from url \"${location}\"`));\n                }\n\n                try {\n                    _.isString(body) && (body = parseJson(body));\n                }\n                catch (e) {\n                    return callback(_.set(e, 'help', `the url \"${location}\" did not provide valid JSON data`));\n                }\n\n                return callback(null, body);\n            }) :\n            fs.readFile(location, function (err, value) {\n                if (err) {\n                    return callback(_.set(err, 'help', `unable to read data from file \"${location}\"`));\n                }\n\n                try {\n                    value = parseJson(value.toString());\n                }\n                catch (e) {\n                    return callback(_.set(e, 'help', `the file at ${location} does not contain valid JSON data`));\n                }\n\n                return callback(null, value);\n            });\n    },\n\n    /**\n     * Loads raw data from a location, useful for working with non JSON data such as CSV files.\n     *\n     * @param {String} location - The relative path / URL to the raw data file.\n     * @param {Object=} options - A set of load options for the raw data file.\n     * @param {Function} callback - The callback function whose invocation marks the end of the fetch routine.\n     * @returns {*}\n     */\n    fetch: function (location, options, callback) {\n        !callback && _.isFunction(options) && (callback = options, options = {});\n        return (/^https?:\\/\\/.*/).test(location) ?\n            // Load from URL\n            request.get({ url: location }, (err, response, body) => {\n                if (err) {\n                    return callback(err);\n                }\n                return callback(null, body);\n            }) :\n            fs.readFile(location, function (err, value) {\n                if (err) {\n                    return callback(err);\n                }\n                return callback(null, value.toString());\n            });\n    }\n};\n\nmodule.exports = util;\n","/home/travis/build/npmtest/node-npmtest-newman/node_modules/newman/lib/run/export-file.js":"var _ = require('lodash'),\n    fs = require('fs'),\n    parsePath = require('path').parse,\n    joinPath = require('path').join,\n    mkdirp = require('mkdirp'),\n\n    /**\n     * The root path specifier\n     *\n     * @const\n     * @private\n     * @type {string}\n     */\n    E = '',\n\n    /**\n     * Default timestamp separator.\n     *\n     * @const\n     * @private\n     * @type {string}\n     */\n    TS_SEP = '-',\n\n    /**\n     * Generate a timestamp from date\n     *\n     * @param {Date=} date - The timestmap used to mark the exported file.\n     * @param {String=} separator - The optional string with which to seperate different sections of the timestamp,\n     * defaults to TS_SEP\n     * @returns {String} - yyyy-mm-dd-HH-MM-SS-MS-0\n     */\n    timestamp = function (date, separator) {\n        // use the iso string to ensure left padding and other stuff is taken care of\n        return (date || new Date()).toISOString().replace(/[^\\d]+/g, _.isString(separator) ? separator : TS_SEP);\n    };\n\n/**\n * Module whose job is to export a file which is in an export format.\n *\n * @param {Object} options - The set of file export options.\n * @param {String} options.path - The path to the exported file.\n * @param {String|Object} options.content - The JSON / stringified content that is to be written to the file.\n * @param {Function} done - The callback whose invocation marks the end of the file export routine.\n * @returns {*}\n */\nmodule.exports = function (options, done) {\n    // parse the path if one is available as string\n    var path = _.isString(options.path) && parsePath(options.path),\n        content = _.isPlainObject(options.content) ? JSON.stringify(options.content, 0, 2) : (options.content || E);\n\n    // if a path was not provided by user, we need to prepare the default path. but create the default path only if one\n    // is provided.\n    if (!path && _.isString(options.default)) {\n        path = parsePath(options.default);\n        // delete the path and directory if one is detected when parsing defaults\n        path.root = E;\n        path.dir = 'newman';\n\n        // append timestamp\n        path.name = `${path.name}-${timestamp()}0`; // @todo make -0 become incremental if file name exists\n        path.base = path.name + path.ext;\n    }\n    // final check that path is valid\n    if (!(path && path.base)) {\n        return;\n    }\n\n    // now sore the unparsed result back for quick re-use during writing and a single place for unparsing\n    path.unparsed = joinPath(path.dir, path.base);\n\n    // in case the path has a directory, ensure that the directory is available\n    if (path.dir) {\n        mkdirp(path.dir, function (err) {\n            if (err) {\n                return done(_.set(err, 'help',\n                    `error creating path for file \"${path.unparsed}\" for ${options.name || 'unknown-source'}`));\n            }\n\n            fs.writeFile(path.unparsed, content, function (err) {\n                done(_.set(err, 'help',\n                    `error writing file \"${path.unparsed}\" for ${options.name || 'unknown-source'}`), path);\n            });\n        });\n    }\n    else {\n        fs.writeFile(path.unparsed, content, function (err) {\n            done(_.set(err, 'help',\n                `error writing file \"${path.unparsed}\" for ${options.name || 'unknown-source'}`), path);\n        });\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-newman/node_modules/newman/lib/run/summary.js":"var _ = require('lodash'),\n    SerialiseError = require('serialised-error'),\n    RunSummary;\n\n/**\n * Creates and returns a RunSummary instance for the current collection run.\n *\n * @constructor\n * @param {EventEmitter} emitter - An EventEmitter instance with event handler attachments to add run information to.\n * @param {Object} options - A set of run summary creation options.\n */\nRunSummary = function RunSummary (emitter, options) {\n    // keep a copy of this instance since, we need to refer to this from various events\n    var summary = this;\n\n    // and store the trackers and failures in the summary object itself\n    _.assign(summary, /** @lends RunSummary.prototype */ {\n        /**\n         * The collection that is being executed.\n         *\n         * @type {Collection}\n         */\n        collection: _.get(options, 'collection'),\n\n        /**\n         * The environment that is being used during the run\n         * @type {VariableScope}\n         *\n         */\n        environment: _.get(options, 'environment'),\n\n        /**\n         * Global variables being used during the run\n         * @type {VariableScope}\n         */\n        globals: _.get(options, 'globals'),\n\n        /**\n         * Holds information related to the run.\n         */\n        run: {\n            /**\n             * Holds the statistics of the run. Each property in it is the item being tracked and has three numeric\n             * properties - total, failed, pending\n             *\n             * @type {Object.<Object>}\n             */\n            stats: {\n                iterations: {},\n                items: {},\n                scripts: {},\n                prerequests: {},\n                requests: {},\n                tests: {},\n                assertions: {},\n                testScripts: {},\n                prerequestScripts: {}\n            },\n\n            /**\n             * Stores all generic timing information\n             *\n             * @type {Object}\n             */\n            timings: {\n                /**\n                 * The average response time of the run\n                 *\n                 * @type {number}\n                 */\n                responseAverage: 0\n            },\n\n            /**\n             * Stores detailed information about the order of execution, request, response and assertions\n             *\n             * @type {Array<Object>}\n             */\n            executions: [],\n\n            /**\n             * Stores information on data transfer made during the collection\n             *\n             * @type {Object}\n             */\n            transfers: {\n                /**\n                 * The total data received as response to every request\n                 *\n                 * @type {number}\n                 */\n                responseTotal: 0\n            },\n\n            /**\n             * An array of all errors encountered during the run\n             *\n             * @type {Array.<Error>}\n             */\n            failures: [],\n\n            /**\n             * This stores any fatal error during the run that caused the run to abort prematurely.\n             *\n             * @type {Error}\n             */\n            error: null\n        }\n    });\n\n    // track run timings (start and end)\n    RunSummary.attachTimingTrackers(this, emitter);\n\n    // accumulate statistics on all event\n    // for all types of events track the counters for the event and its corresponding \"before\" counterpart\n    RunSummary.attachStatisticTrackers(this, emitter);\n\n    // accumulate statistics on requests - such as size and time\n    RunSummary.attachRequestTracker(this, emitter);\n\n    // accumulate errors (failures) from all events\n    RunSummary.attachFailureTrackers(this, emitter);\n\n    // accumulate all execution specific data in collection\n    RunSummary.attachReportingTrackers(this, emitter);\n};\n\n_.assign(RunSummary, {\n    attachReportingTrackers: function (summary, emitter) {\n        var cache = {},\n            executions = summary.run.executions;\n\n        emitter.on('beforeItem', function (err, o) {\n            if (!_.get(o, 'cursor.ref')) { return; }\n\n            cache[o.cursor.ref] = _.assignIn(cache[o.cursor.ref] || {}, {\n                cursor: o.cursor,\n                item: o.item\n            });\n        });\n\n        // save all responses in executions array\n        emitter.on('request', function (err, o) {\n            if (!_.get(o, 'cursor.ref')) { return; }\n\n            var execution = cache[o.cursor.ref] = (cache[o.cursor.ref] || {});\n\n            executions.push(_.assignIn(execution, {\n                cursor: o.cursor,\n                request: o.request,\n                response: _.omit(o.response, 'stream'),\n                id: _.get(o, 'item.id')\n            }, err && {\n                requestError: err || undefined\n            }));\n        });\n\n        // save all script execution errors in each execution\n        emitter.on('script', function (err, o) {\n            if (!_.get(o, 'cursor.ref')) { return; }\n\n            var execution = cache[o.cursor.ref] = (cache[o.cursor.ref] || {}),\n                eventName = o && o.event && (o.event.listen + 'Script');\n\n            // store the script error corresponding to the script event name\n            err && (execution && eventName) && (execution[eventName] || (execution[eventName] = [])).push({\n                error: err\n            });\n        });\n\n        // save all assertions in each execution\n        emitter.on('assertion', function (err, o) {\n            if (!_.get(o, 'cursor.ref')) { return; }\n\n            var execution = cache[o.cursor.ref] = (cache[o.cursor.ref] || {});\n            if (!execution) { return; }\n\n            (execution.assertions || (execution.assertions = [])).push({\n                assertion: o.assertion,\n                error: err || undefined\n            });\n        });\n    },\n\n    attachTimingTrackers: function (summary, emitter) {\n        // mark the point when the run started\n        // also mark the point when run completed and also store error if needed\n        emitter.on('start', function () { summary.run.timings.started = Date.now(); });\n        emitter.on('beforeDone', function () {\n            summary.run.timings.completed = Date.now();\n        });\n        emitter.on('done', function (err) {\n            err && (summary.error = err);\n        });\n    },\n    attachStatisticTrackers: function (summary, emitter) {\n        // accumulate statistics on all event\n        // for all types of events track the counters for the event and its corresponding \"before\" counterpart\n        _.forEach(summary.run.stats, function (tracker, name) {\n            // the actual event names are singular than their plural trackers, so we make the name singular\n            name = name.slice(0, -1); // remove last character\n\n            // populate initial values of trackers\n            _.assign(tracker, { total: 0, pending: 0, failed: 0 });\n\n            // Set up common listeners for a set of events, which tracks how many times they were executed and records\n            // the ones which had an error passed as first argument\n            emitter.on(_.camelCase('before-' + name), function () {\n                tracker.pending += 1;\n            });\n\n            emitter.on(name, function (err) {\n                // check pending so that, it does not negate for items that do not have a `before` counterpart\n                tracker.pending && (tracker.pending -= 1);\n                err && (tracker.failed += 1);\n                tracker.total += 1;\n            });\n        });\n    },\n\n    attachRequestTracker: function (summary, emitter) {\n        // accumulate statistics on requests\n        emitter.on('request', function (err, o) {\n            if (err || !(o && o.response)) { return; }\n\n            var size = _.isFunction(o.response.size) && o.response.size(),\n                time = o.response.responseTime,\n\n                requestCount = summary.run.stats.requests.total;\n\n            // compute the response size total\n            size && (summary.run.transfers.responseTotal += (size.body || 0 + size.headers || 0));\n\n            // compute average response time\n            time && (summary.run.timings.responseAverage =\n                ((summary.run.timings.responseAverage * (requestCount - 1) + time) / requestCount));\n        });\n    },\n\n    attachFailureTrackers: function (summary, emitter) {\n        var eventsToTrack = ['beforeIteration', 'iteration', 'beforeItem', 'item', 'beforeScript', 'script',\n            'beforePrerequest', 'prerequest', 'beforeRequest', 'request', 'beforeTest', 'test', 'beforeAssertion',\n            'assertion'];\n\n        // accumulate failures of all events\n        // NOTE that surrogate events (which throw duplicate arguments) are not recorded\n        _.forEach(eventsToTrack, function (event) {\n            // push failures sent from \"before\" events\n            emitter.on(event, function (err, o) {\n                if (!err) { return; }\n\n                var item = o && o.item,\n                    source = event;\n\n                // in case of user script error, point to the line and column of the script and its type\n                if (event === 'script') {\n                    o.event && (source = o.event.listen + '-script');\n                    if (err.stacktrace && err.stacktrace[0] && err.stacktrace[0].lineNumber) {\n                        source += (':' + (err.stacktrace[0].lineNumber - 2));\n                        err.stacktrace[0].columnNumber && (source += (':' + err.stacktrace[0].columnNumber));\n                    }\n                }\n                // assertion errors need to know which assertion in the test was this\n                else if (event === 'assertion') {\n                    _.has(err, 'index') && (source += (':' + (err.index + 1)));\n                    source += ' in test-script';\n                }\n\n                // if this is a plain error, convert it to serialised error\n                if (err.stack && !err.stacktrace) {\n                    err = new SerialiseError(err, true);\n                }\n\n                summary.run.failures.push({\n                    error: err,\n                    at: source,\n                    source: item || undefined,\n                    parent: item && item.__parent && item.__parent.__parent || undefined,\n                    cursor: o.cursor || {}\n                });\n            });\n        });\n    }\n});\n\nmodule.exports = RunSummary;\n","/home/travis/build/npmtest/node-npmtest-newman/node_modules/newman/lib/run/options.js":"var _ = require('lodash'),\n    async = require('async'),\n    transformer = require('postman-collection-transformer'),\n    Collection = require('postman-collection').Collection,\n    VariableScope = require('postman-collection').VariableScope,\n    parseJson = require('parse-json'),\n    parseCsv = require('csv-parse'),\n    util = require('../util'),\n    config = require('../config'),\n\n    /**\n     * The message displayed when the specified collection file can't be loaded.\n     *\n     * @const\n     * @type {String}\n     */\n    COLLECTION_LOAD_ERROR_MESSAGE = 'newman: collection could not be loaded',\n\n    /**\n     * The message displayed when the specified environment or globals file can't be loaded.\n     *\n     * @const\n     * @type {String}\n     */\n    LOAD_ERROR_MESSAGE = 'newman: could not load ',\n\n    /**\n     * The set of postman collection transformer options, to convert collection v1 to collection v2.\n     *\n     * @const\n     * @type {Object}\n     */\n    COLLECTION_TRANSFORMER_OPTION = { inputVersion: '1.0.0', outputVersion: '2.0.0' },\n\n    /**\n     * Accepts an object, and extracts the property inside an object which is supposed to contain the required data.\n     * In case of variables, it also extracts them into plain JS objects.\n     *\n     * @param {Object} source - The source wrapper object that may or may not contain inner wrapped properties.\n     * @param {String} type - \"environment\" or \"globals\", etc.\n     * @returns {Object} - The object representation of the current extracted property.\n     */\n    extractModel = function (source, type) {\n        source = source[type] || source; // extract object that holds variable. these usually come from cloud API\n        if (!_.isObject(source)) {\n            return undefined;\n        }\n\n        // ensure we un-box the JSON if it comes from cloud-api or similar sources\n        !source.values && _.isObject(source[type]) && (source = source[type]);\n\n        // we ensure that environment passed as array is converted to plain object. runtime does this too, but we do it\n        // here for consistency of options passed to reporters\n        return source;\n    },\n\n    /**\n     * Loads the given data of type from a specified external location\n     *\n     * @param {String} type - The type of data to load.\n     * @param {String} location - The location to load from (file path or URL).\n     * @param {function} cb - The callback function whose invocation marks the end of the external load routine.\n     * @returns {*}\n     */\n    externalLoader = function (type, location, cb) {\n        return _.isString(location) ? util.fetchJson(location, function (err, data) {\n            if (err) {\n                return cb(err);\n            }\n            return cb(null, extractModel(data, type));\n        }) : cb(null, extractModel(location, type));\n    },\n\n    /**\n     * A helper method to process a collection and convert it to a V2 equivalent if necessary, and return it.\n     *\n     * @param {Object} collection The input collection, specified as a JSON object.\n     * @param {Function} callback A handler function that consumes an error object and the processed collection.\n     * @returns {*|Function} -\n     */\n    processCollection = function (collection, callback) {\n        return transformer.isv1(collection) ? transformer.convert(collection, COLLECTION_TRANSFORMER_OPTION, callback) :\n            callback(null, collection);\n    },\n\n    /**\n     * Helper function that manages the load of environments and globals\n     * @private\n     *\n     * @param {String} type\n     * @param {String|Object} value\n     * @param {Function} callback\n     */\n    loadScopes = function (type, value, callback) {\n        var done = function (err, scope) {\n            if (err) { return callback(err); }\n\n            if (!_.isObject(scope)) {\n                return done(new Error(LOAD_ERROR_MESSAGE + type));\n            }\n\n            callback(null, new VariableScope(VariableScope.isVariableScope(scope) ? scope.toJSON() : scope));\n        };\n\n        if (_.isObject(value)) {\n            return done(null, value);\n        }\n\n        externalLoader(type, value, done);\n    },\n\n    /**\n     * Custom configuration loaders for the required configuration keys.\n     *\n     * @type {Object}\n     */\n    configLoaders = {\n\n        /**\n         * The collection file load helper for the current run.\n         *\n         * @param {Object|String} value - The collection, specified as a JSON object, or the path to it's file.\n         * @param {Function} callback - The callback function invoked to mark the end of the collection load routine.\n         * @return {*}\n         */\n        collection: function (value, callback) {\n\n            /**\n             * The post collection load handler.\n             *\n             * @param {?Error} err - An Error instance / null, passed from the collection loader.\n             * @param {Object} collection - The collection / raw JSON object, passed from the collection loader.\n             * @returns {*}\n             */\n            var done = function (err, collection) {\n                if (err) {\n                    return callback(err);\n                }\n\n                // ensure that the collection option is present before starting a run\n                if (!_.isObject(collection)) {\n                    return callback(new Error(COLLECTION_LOAD_ERROR_MESSAGE));\n                }\n\n                // ensure that the collection reference is an SDK instance\n                // @todo - should this be handled by config loaders?\n                collection = new Collection(Collection.isCollection(collection) ?\n                    // if the option contain an instance of collection, we simply clone it for future use\n                    // create a collection in case it is not one. user can send v2 JSON as a source and that will be\n                    // converted to a collection\n                    collection.toJSON() : collection);\n\n                callback(null, collection);\n            };\n\n            // if the collection has been specified as an object, convert to V2 if necessary and return the result\n            if (_.isObject(value)) {\n                return processCollection(value, done);\n            }\n\n            externalLoader('collection', value, function (err, data) {\n                if (err) {\n                    return done(err);\n                }\n                if (!_.isObject(data)) {\n                    return done(new Error(COLLECTION_LOAD_ERROR_MESSAGE));\n                }\n                return processCollection(data, done);\n            });\n        },\n\n        /**\n         * The environment configuration object, loaded for the current collection run.\n         *\n         * @type {Object}\n         */\n        environment: loadScopes.bind(this, 'environment'),\n\n        /**\n         * The object of globals, loaded for the collection run.\n         *\n         * @type {Object}\n         */\n        globals: loadScopes.bind(this, 'globals'),\n\n        /**\n         * The iterationData loader module, with support for JSON or CSV data files.\n         *\n         * @param {String|Object[]} location - The path to the iteration data file for the current collectio run, or\n         * the array of iteration data objects.\n         * @param {Function} callback - The function invoked to indicate the end of the iteration data loading routine.\n         * @returns {*}\n         */\n        iterationData: function (location, callback) {\n            if (_.isArray(location)) { return callback(null, location); }\n\n            util.fetch(location, function (err, data) {\n                if (err) {\n                    return callback(err);\n                }\n\n                // Try loading as a JSON, fallback to CSV. @todo: switch to file extension based loading.\n                async.waterfall([\n                    (cb) => {\n                        try {\n                            return cb(null, parseJson(data));\n                        }\n                        catch (e) {\n                            return cb(null, undefined); // e masked to avoid displaying JSON parse errors for CSV files\n                        }\n                    },\n                    (json, cb) => {\n                        if (json) {\n                            return cb(null, json);\n                        }\n                        // Wasn't JSON\n                        parseCsv(data, { columns: true, escape: '\\\\' }, cb);\n                    }\n                ], (err, parsed) => {\n                    if (err) {\n                        // todo: Log meaningful stuff here\n                        return callback(err);\n                    }\n\n                    callback(null, parsed);\n                });\n            });\n        }\n    };\n\n/**\n * The helper function to load all file based information for the current collection run.\n *\n * @param {Object} options - The set of generic collection run options.\n * @param {Function} callback - The function called to mark the completion of the configuration load routine.\n * @returns {*}\n */\nmodule.exports = function (options, callback) {\n    config.get(options, { loaders: configLoaders, command: 'run' }, callback);\n};\n","/home/travis/build/npmtest/node-npmtest-newman/node_modules/newman/lib/config/index.js":"var _ = require('lodash'),\n    async = require('async'),\n\n    env = require('./process-env'),\n    rcfile = require('./rc-file');\n\n/**\n * Reads configuration from config file, environment variables and CLI arguments. The CLI arguments override environment\n * variables and environment variables override the configuration read from a file.\n *\n * @param {Object} overrides - Configuration overrides (these usually come from the CLI).\n * @param {Object} options - The wrapper object of settings used for selective configuration loading.\n * @param {String} options.command - Command name. Used for loading the required options from the config file.\n * @param {Boolean=} options.ignoreRcFile - If true, the RC file is ignored.\n * @param {Boolean=} options.ignoreProcessEnvironment - If true, the process environment variables are ignored.\n * @param {Object=} options.loaders - Custom loaders for specific configuration options.\n * @param {Function} callback - Is called after merging values from the overrides with the values from the rc file and\n * environment variables.\n * @returns {*}\n */\nmodule.exports.get = (overrides, options, callback) => {\n    !callback && _.isFunction(options) && (callback = options, options = {});\n\n    var loaders = options.loaders;\n    async.waterfall([\n        // Load RC Files.\n        !options.ignoreRcFile ? rcfile.load : (cb) => {\n            return cb(null, {});\n        },\n        // Load Process Environment overrides\n        (fileOptions, cb) => {\n            fileOptions[options.command] && (fileOptions = fileOptions[options.command]);\n            return cb(null, _.merge(fileOptions, options.ignoreProcessEnvironment ? {} : env));\n        }\n    ], (err, options) => {\n        if (err) {\n            return callback(err);\n        }\n\n        options = _.mergeWith({}, options, overrides, (dest, src) => {\n            // If the newer value is a null, do not override it.\n            return (src === null) ? dest : undefined;\n        });\n\n        if (_.isEmpty(loaders)) {\n            return callback(null, options);\n        }\n        // sanitize environment option\n        if (!options.environment) {\n            options.environment = {};\n        }\n        // sanitize globals option\n        if (!options.globals) {\n            options.globals = {};\n        }\n\n        async.mapValues(options, (value, name, cb) => {\n            return (value && _.isFunction(loaders[name])) ? loaders[name](value, cb) : cb(null, value);\n        }, callback);\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-newman/node_modules/newman/lib/config/process-env.js":"var envConfig = {}; // todo: read NEWMAN_* variables from process.env\n\nmodule.exports = envConfig;\n","/home/travis/build/npmtest/node-npmtest-newman/node_modules/newman/lib/config/rc-file.js":"var _ = require('lodash'),\n    fs = require('fs'),\n    join = require('path').join,\n    async = require('async'),\n    parseJson = require('parse-json'),\n\n    /**\n     * Name of the directory that contains the file denoted by FILE_NAME.\n     *\n     * @type {String}\n     */\n    POSTMAN_CONFIG_DIR = 'postman',\n\n    /**\n     * Name of the file that contains Newman compliant confguration information.\n     *\n     * @type {String}\n     */\n    FILE_NAME = 'newmanrc';\n\n/**\n * Configuration loader to acquire run settings from a file present in the home directory: POSTMAN_CONFIG_DIR/FILE_NAME.\n *\n * @param {Function} callback - The callback function invoked to mark the completion of the config loading routine.\n * @returns {*}\n */\nmodule.exports.load = (callback) => {\n    var iswin = (/^win/).test(process.platform),\n        home = iswin ? process.env.USERPROFILE : process.env.HOME,\n\n        configFiles = [];\n\n    configFiles.push(join(process.cwd(), '.' + FILE_NAME));\n    home && configFiles.push(join(home, '.' + POSTMAN_CONFIG_DIR, FILE_NAME));\n    !iswin && configFiles.push(join('/etc', POSTMAN_CONFIG_DIR, FILE_NAME));\n\n    async.mapSeries(configFiles, (path, cb) => {\n        fs.readFile(path, (err, data) => {\n            if (err) {\n                return cb(null, {}); // err masked to avoid overpopulating terminal with missing .newmanrc messages\n            }\n            data && data.toString && (data = data.toString());\n            try {\n                return cb(null, parseJson(data));\n            }\n            catch (e) {\n                return cb(_.set(e, 'help', `The file at ${path} contains invalid data.`));\n            }\n        });\n    }, (err, files) => {\n        if (err) {\n            return callback(err);\n        }\n\n        return callback(null, _.merge.apply(this, files));\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-newman/node_modules/newman/lib/reporters/cli/index.js":"var _ = require('lodash'),\n    colors = require('colors/safe'),\n    Table = require('cli-table2'),\n    format = require('util').format,\n\n    util = require('../../util'),\n    cliUtils = require('./cli-utils'),\n    print = require('../../print'),\n    pad = cliUtils.padLeft,\n\n    LF = '\\n',\n    SPC = ' ',\n    DOT = '.',\n    E = '',\n\n    PostmanCLIReporter;\n\n// sets theme for colors for console logging\ncolors.setTheme({\n    log: 'grey',\n    info: 'cyan',\n    warn: 'yellow',\n    debug: 'blue',\n    error: 'red'\n});\n\n/**\n * CLI reporter\n *\n * @param {EventEmitter} emitter - An EventEmitter instance with event handler attachers to trigger reporting.\n * @param {Object} reporterOptions - CLI reporter options object.\n * @param {Boolean=} reporterOptions.silent - Boolean flag to turn off CLI reporting altogether, if set to true.\n * @param {Boolean=} reporterOptions.noAssertions - Boolean flag to turn off assertion reporting, if set to true.\n * @param {Boolean=} reporterOptions.noSummary - Boolean flag to turn off summary reporting altogether, if set to true.\n * @param {Boolean=} reporterOptions.noFailures - Boolean flag to turn off failure reporting altogether, if set to true.\n * @param {Boolean=} reporterOptions.noConsole - Boolean flag to turn off console logging, if set to true.\n * @param {Object} options - A set of generic collection run options.\n * @returns {*}\n */\nPostmanCLIReporter = function (emitter, reporterOptions, options) {\n    var currentGroup = options.collection,\n        inspect = cliUtils.inspector(options),\n        wrap = cliUtils.wrapper(),\n        symbols = cliUtils.symbols(options.disableUnicode);\n\n    // respect silent option to not report anything\n    if (reporterOptions.silent || options.silent) {\n        return; // we simply do not register anything!\n    }\n\n    // we register the `done` listener first so that in case user does not want to show results of collection run, we\n    // simply do not register the other events\n    emitter.on('done', function () {\n        // for some reason, if there is no run summary, it is unexpected and hence don't validate this\n        var run = this.summary.run;\n\n        // show the summary table (provided option does not say it is not to be shown)\n        if (!reporterOptions.noSummary) {\n            // @todo: possible missing .toString() call on parseStatistics below? (see parseFailures call below)\n            print(LF + PostmanCLIReporter.parseStatistics(run.stats, run.timings, run.transfers, options) + LF);\n        }\n\n        // show the failures table (provided option does not say it is not to be shown)\n        if (!reporterOptions.noFailures && run.failures && run.failures.length) {\n            print(LF + PostmanCLIReporter.parseFailures(run.failures).toString() + LF);\n        }\n    });\n\n    // in case user does not want to show results of collection run, we simply do not register the other events.\n    if (reporterOptions.noAssertions) {\n        return;\n    }\n\n    emitter.on('start', function () {\n        var collectionIdentifier = currentGroup && (currentGroup.name || currentGroup.id);\n\n        // print the newman banner\n        print('%s\\n\\n', colors.reset('newman'));\n\n        // print the collection name and newman info line\n        collectionIdentifier && print.lf('%s', colors.reset(collectionIdentifier));\n    });\n\n    emitter.on('beforeIteration', function (err, o) {\n        if (err || o.cursor.cycles <= 1) {\n            return; // do not print iteration banner if it is a single iteration run\n        }\n\n        // print the iteration info line\n        print.lf(LF + colors.gray.underline('Iteration %d/%d'), o.cursor.iteration + 1, o.cursor.cycles);\n    });\n\n    emitter.on('beforeItem', function (err, o) {\n        var itemGroup = o.item.parent(),\n            root = !itemGroup || (itemGroup === options.collection);\n\n        // in case this item belongs to a separate folder, print that folder name\n        if (itemGroup && (currentGroup !== itemGroup)) {\n            !root && print('\\n%s %s', symbols.folder, colors.reset(util.getFullName(itemGroup)));\n\n            // set the flag that keeps track of the currently running group\n            currentGroup = itemGroup;\n        }\n\n        // we print the item name. the symbol prefix denotes if the item is in root or under folder.\n        // @todo - when we do indentation, we would not need symbolic representation\n        o.item && print.lf('\\n%s %s', (root ?\n            symbols.root : symbols.sub), colors.reset(o.item.name || E));\n    });\n\n    // print out the request name to be executed and start a spinner\n    emitter.on('beforeRequest', function (err, o) {\n        o.request && print('  %s %s ', colors.gray(o.request.method), colors.gray(o.request.url)).wait(colors.gray);\n    });\n\n    // output the response code, reason and time\n    emitter.on('request', function (err, o) {\n        var size = o.response && o.response.size();\n        size = size && (size.header || 0) + (size.body || 0) || 0;\n\n        err ? print.lf(colors.red('[errored]')) :\n            print.lf(colors.gray('[%d %s, %s, %s]'), o.response.code, o.response.reason(),\n                util.filesize(size), util.prettyms(o.response.responseTime));\n    });\n\n    // Print script errors in real time\n    emitter.on('script', function (err, o) {\n        err && print.lf(colors.red.bold('%s⠄ %s in %s-script'), pad(this.summary.run.failures.length, 3, SPC), err.name,\n            o.event && o.event.listen || 'unknown');\n    });\n\n    emitter.on('assertion', function (err, o) {\n        var passed = !err;\n\n        // print each test assertions\n        print.lf('%s %s', passed ? colors.green(`  ${symbols.ok} `) :\n            colors.red.bold(pad(this.summary.run.failures.length, 3, SPC) + symbols.dot), passed ?\n            colors.gray(o.assertion) : colors.red.bold(o.assertion));\n    });\n\n    // show user console logs in a neatly formatted way (provided user has not disabled the same)\n    !reporterOptions.noConsole && emitter.on('console', function (err, o) {\n        var color = colors[o.level] || colors.gray,\n            message;\n\n        // we first merge all messages to a string. while merging we run the values to util.inspect to colour code the\n        // messages based on data type\n        message = wrap(_.reduce(o.messages, function (log, message) { // wrap the whole message to the window size\n            return (log += (log ? colors.white(', ') : '') + inspect(message));\n        }, E), `  ${color(symbols.console.middle)} `); // add an indentation line at the beginning\n\n        print.buffer(color(`  ${symbols.console.top}\\n`), color(`  ${symbols.console.bottom}\\n`))\n            // tweak the message to ensure that its surrounding is not brightly coloured.\n            // also ensure to remove any blank lines generated due to util.inspect\n            .nobuffer(colors.gray(message.replace(/\\n\\s*\\n/g, LF) + LF));\n    });\n};\n\n_.assignIn(PostmanCLIReporter, {\n\n    // @todo: change function signature to accept run object and options, thereby reducing parameters\n    /**\n     * A CLI reporter method to parse collection run statistics into a CLI table.\n     *\n     * @param {Object} stats - The cumulative collection run status object.\n     * @param {Object} stats.iterations - A set of values for total, pending, and failed iterations.\n     * @param {Number} stats.iterations.total - Total iterations in the current collection run.\n     * @param {Number} stats.iterations.pending - Pending iterations in the current collection run.\n     * @param {Number} stats.iterations.failed - Failed iterations in the current collection run.\n     * @param {Object} stats.requests - A set of values for total, pending, and failed requests.\n     * @param {Number} stats.requests.total - Total requests in the current collection run.\n     * @param {Number} stats.requests.pending - Pending requests in the current collection run.\n     * @param {Number} stats.requests.failed - Failed requests in the current collection run.\n     * @param {Object} stats.testScripts - A set of values for total, pending, and failed testScripts.\n     * @param {Number} stats.testScripts.total - Total testScripts in the current collection run.\n     * @param {Number} stats.testScripts.pending - Pending testScripts in the current collection run.\n     * @param {Number} stats.testScripts.failed - Failed testScripts in the current collection run.\n     * @param {Object} stats.prerequestScripts - A set of values for total, pending, and failed prerequestScripts.\n     * @param {Number} stats.prerequestScripts.total - Total prerequestScripts in the current collection run.\n     * @param {Number} stats.prerequestScripts.pending - Pending prerequestScripts in the current collection run.\n     * @param {Number} stats.prerequestScripts.failed - Failed prerequestScripts in the current collection run.\n     * @param {Object} stats.assertions - A set of values for total, pending, and failed assertions.\n     * @param {Number} stats.assertions.total - Total assertions in the current collection run.\n     * @param {Number} stats.assertions.pending - Pending assertions in the current collection run.\n     * @param {Number} stats.assertions.failed - Failed assertions in the current collection run.\n     * @param {Object} timings - A set of values for the timings of the current collection run.\n     * @param {Number} timings.completed - The end timestamp for the current collection run.\n     * @param {Number} timings.started - The start timestamp for the current collection run\n     * @param {String} timings.responseAverage - The average response time across all requests\n     * @param {Object} transfers - A set of details on the network usage for the current collection run.\n     * @param {String} transfers.responseTotal - The net extent of the data transfer achieved during the collection run.\n     * @param {Object} options - The set of generic collection run options.\n     * @return {Table} - The constructed collection run statistics table.\n     */\n    parseStatistics: function (stats, timings, transfers, options) {\n        var summaryTable;\n\n        // create the summary table\n        summaryTable = new Table({\n            chars: options.disableUnicode && cliUtils.cliTableTemplateFallback,\n            style: { head: [] },\n            head: [E, 'executed', '  failed'],\n            colAligns: ['right', 'right', 'right'],\n            colWidths: [25]\n        });\n\n        // add specific rows to show in summary\n        stats && _.forEach([{\n            source: 'iterations',\n            label: 'iterations'\n        }, {\n            source: 'requests',\n            label: 'requests'\n        }, {\n            source: 'testScripts',\n            label: 'test-scripts'\n        }, {\n            source: 'prerequestScripts',\n            label: 'prerequest-scripts'\n        }, {\n            source: 'assertions',\n            label: 'assertions'\n        }], function (row) {\n            var metric = stats[row.source],\n                label = row.label;\n\n            // colour the label based on the failure or pending count of the metric\n            label = metric.failed ? colors.red(label) : (metric.pending ? label : colors.green(label));\n\n            // push the statistics\n            summaryTable.push([\n                label,\n                metric.total,\n                (metric.failed ? colors.red(metric.failed) : metric.failed)\n                // @todo - add information of pending scripts\n                // (metric.failed ? colors.red(metric.failed) : metric.failed) +\n                //     (metric.pending ? format(' (%d pending)', metric.pending) : E)\n            ]);\n        });\n\n        // add the total execution time to summary\n        timings && summaryTable.push([{\n            colSpan: 3,\n            content: format('total run duration: %s', util.prettyms(timings.completed - timings.started)),\n            hAlign: 'left' // since main style was set to right\n        }]);\n\n        // add row to show total data received\n        transfers && summaryTable.push([{\n            colSpan: 3,\n            content: format('total data received: %s (approx)', util.filesize(transfers.responseTotal)),\n            hAlign: 'left'\n        }]);\n\n        // add row to show average response time\n        summaryTable.push([{\n            colSpan: 3,\n            content: format('average response time: %s', util.prettyms(timings.responseAverage)),\n            hAlign: 'left'\n        }]);\n\n        return summaryTable;\n    },\n\n    /**\n     * A CLI reporter method to parse collection run failure statistics into a CLI table.\n     *\n     * @param  {Array} failures - An array of failure objects.\n     * @return {Table} - The constructed CLI failure Table object.\n     */\n    parseFailures: function (failures) {\n        var failureTable = new Table({\n            head: [{\n                hAlign: 'right',\n                content: colors.red.underline('#')\n            }, colors.red.underline('failure'),\n                colors.red.underline('detail')],\n            chars: cliUtils.cliTableTemplate_Blank,\n            wordWrap: true,\n            colAligns: ['right'],\n            colWidths: cliUtils.noTTY() ? [] : (function (size, indexOrder) {\n                var colWidths;\n\n                if (size.exists && size.width && (size.width > 20)) {\n                    colWidths = [];\n                    colWidths[0] = indexOrder + 3;\n                    colWidths[1] = parseInt((size.width - colWidths[0]) * 0.2, 10);\n                    colWidths[2] = parseInt(size.width - (colWidths[0] + colWidths[1] + 5), 10);\n                }\n\n                return colWidths;\n            }(cliUtils.dimension(), Number(failures.length.toString().length)))\n        });\n\n        _.forEach(failures, function (failure, index) {\n            var name = failure.error && failure.error.name || E,\n                message = failure.error && failure.error.message || E;\n\n            // augment name with iteration information\n            failure.cursor && (failure.cursor.cycles > 1) &&\n                (name += LF + colors.gray('iteration: ' + (failure.cursor.iteration + 1)));\n\n            // augment the message with stack information\n            failure.at && (message += LF + colors.gray('at ' + failure.at));\n\n            // augment message with item information\n            failure.source &&\n                (message += format(colors.gray('\\ninside \"%s\"'), util.getFullName(failure.source)));\n\n            // augment message with item parent information\n            failure.source && failure.parent &&\n                (message += format(colors.gray(' of \"%s\"'), util.getFullName(failure.parent)));\n\n\n            failureTable.push([pad(Number(index + 1), Number(failures.length.toString().length)).toString() +\n                DOT, name, message]);\n        });\n\n        return failureTable;\n    }\n});\n\n// Mark the CLI reporter as dominant, so that no two dominant reporters are together\nPostmanCLIReporter.prototype.dominant = true;\n\nmodule.exports = PostmanCLIReporter;\n","/home/travis/build/npmtest/node-npmtest-newman/node_modules/newman/lib/reporters/cli/cli-utils.js":"var inspect = require('util').inspect,\n    wrap = require('word-wrap'),\n    symbols = require('./cli-utils-symbols'),\n\n    cliUtils;\n\n// set styling for inspect options\ninspect.styles.string = 'grey';\ninspect.styles.name = 'white';\n\ncliUtils = {\n\n    /**\n     * A helper method that picks the right set of symbols for the given set of run conditions.\n     *\n     * @type {Function}\n     */\n    symbols: symbols,\n\n    /**\n     * A set of blank CLI table symbols (default).\n     *\n     * @type {Object}\n     */\n    cliTableTemplate_Blank: {\n        'top': '',\n        'top-mid': '',\n        'top-left': '',\n        'top-right': '',\n        'bottom': '',\n        'bottom-mid': '',\n        'bottom-left': '',\n        'bottom-right': '',\n        'middle': '',\n        'mid': ' ',\n        'mid-mid': '',\n        'mid-left': '',\n        'mid-right': '',\n        'left': '',\n        'left-mid': '',\n        'left-left': '',\n        'left-right': '',\n        'right': '',\n        'right-mid': '',\n        'right-left': '',\n        'right-right': ''\n    },\n\n    /**\n     * A set of fallback CLI table construction symbols, used when unicode has been disabled.\n     *\n     * @type {Object}\n     */\n    cliTableTemplateFallback: {\n        'top': '-',\n        'top-mid': '-',\n        'top-left': '-',\n        'top-right': '-',\n        'bottom': '-',\n        'bottom-mid': '-',\n        'bottom-left': '-',\n        'bottom-right': '-',\n        'middle': '|',\n        'mid': '-',\n        'mid-mid': '+',\n        'mid-left': '-',\n        'mid-right': '-',\n        'left': '|',\n        'left-mid': '-',\n        'left-left': '-',\n        'left-right': '-',\n        'right': '|',\n        'right-mid': '-',\n        'right-left': '-',\n        'right-right': '-'\n    },\n\n    /**\n     * A CLI utility helper method that perfoms left padding on an input string.\n     *\n     * @param {String} nr - The string to be padded.\n     * @param {Number} n - The length of the field, in which to left pad the input string.\n     * @param {String=} str - An optional string used for padding the input string. Defaults to '0'.\n     * @returns {String} - The resultant left padded string.\n     */\n    padLeft: function (nr, n, str) {\n        return Array(n - String(nr).length + 1).join(str || '0') + nr;\n    },\n\n    /**\n     * A CLI utility helper method that checks for the non TTY compliance of the current run environment.\n     *\n     * @param {Boolean} - A flag to indicate usage of the --color option.\n     * @returns {Boolean} - A boolean value depicting the result of the noTTY check.\n     */\n    noTTY: function (color) {\n        return !color && (Boolean(process.env.CI) || !process.stdout.isTTY);\n    },\n\n    /**\n     * A CLI utility helper method that generates a color inspector function for CLI reports.\n     *\n     * @param {Object} runOptions - The set of run options acquired via the runner.\n     * @return {Function} - A function to perform utils.inspect, given a sample item, under pre-existing options.\n     */\n    inspector: function (runOptions) {\n        var dimension = cliUtils.dimension(),\n            options = {\n                colors: !(runOptions.noColor || cliUtils.noTTY(runOptions.color)),\n                // note that similar dimension calculation is in utils.wrapper\n                breakLength: ((dimension.exists && (dimension.width > 20)) ? dimension.width : 60) - 16\n            };\n\n        return function (item) {\n            return inspect(item, options);\n        };\n    },\n\n    /**\n     * A CLI utility helper method to provide content wrapping functionality for CLI reports.\n     *\n     * @return {Function} - A sub-method to wrap content, given a piece of text, and indent value.\n     */\n    wrapper: function () {\n        var dimension = cliUtils.dimension(),\n            // note that similar dimension calculation is in utils.wrapper\n            width = ((dimension.exists && (dimension.width > 20)) ? dimension.width : 60) - 6;\n\n        return function (text, indent) {\n            return wrap(text, {\n                indent: indent,\n                width: width,\n                cut: true\n            });\n        };\n    },\n\n    /**\n     * A CLI utility helper method to compute and scae the size of the CLI table to be displayed.\n     *\n     * @return {Object} - A set of properties: width, height, and TTY existance.\n     */\n    dimension: function () {\n        var tty,\n            width,\n            height;\n\n        try { tty = require('tty'); }\n        catch (e) { tty = null; }\n\n        if (tty && tty.isatty(1) && tty.isatty(2)) {\n            if (process.stdout.getWindowSize) {\n                width = process.stdout.getWindowSize(1)[0];\n                height = process.stdout.getWindowSize(1)[1];\n            }\n            else if (tty.getWindowSize) {\n                width = tty.getWindowSize()[1];\n                height = tty.getWindowSize()[0];\n            }\n            else if (process.stdout.columns && process.stdout.rows) {\n                height = process.stdout.rows;\n                width = process.stdout.columns;\n            }\n        }\n\n        return {\n            exists: !(Boolean(process.env.CI) || !process.stdout.isTTY),\n            width: width,\n            height: height\n        };\n    }\n};\n\nmodule.exports = cliUtils;\n","/home/travis/build/npmtest/node-npmtest-newman/node_modules/newman/lib/reporters/cli/cli-utils-symbols.js":"var IS_WINDOWS = (/^win/).test(process.platform),\n    subsets,\n    symbols;\n\n/**\n * A set of symbol groups for use in different situations: regular, windows friendly unicode, and plain text.\n *\n * @type {Object}\n */\nsubsets = {\n    regular: {\n        console: {\n            top: '┌',\n            middle: '│',\n            bottom: '└'\n        },\n        dot: '.',\n        folder: '❏',\n        root: '→',\n        sub: '↳',\n        ok: '✓',\n        error: '✖'\n    },\n    encoded: {\n        console: {\n            top: '\\u250C',\n            middle: '\\u2502',\n            bottom: '\\u2514'\n        },\n        dot: '.',\n        folder: '\\u25A1',\n        root: '\\u2192',\n        sub: '\\u2514',\n        ok: '\\u221A',\n        error: '\\u00D7'\n    },\n    plainText: {\n        console: {\n            top: '-',\n            middle: '|',\n            bottom: '-'\n        },\n        dot: '.',\n        folder: 'Folder',\n        root: 'Root',\n        sub: 'Sub-folder',\n        ok: 'Pass',\n        error: 'Fail'\n    }\n};\n\n/**\n * A method that picks the appropriate set of CLI report symbols under a given set of run conditions.\n *\n * @param  {Boolean} disableUnicode - A flag to force plain text equivalents for CLI symbols if set to true.\n * @returns {Object} - The right set of symbols from subsets for the given conditions.\n * @todo Add additional parameter related to temp file read - writes\n */\nsymbols = function (disableUnicode) {\n    if (disableUnicode) {\n        return subsets.plainText;\n    }\n    if (IS_WINDOWS) { // modify symbols for windows platforms\n        return subsets.encoded;\n    }\n\n    return subsets.regular;\n};\n\nmodule.exports = symbols;\n","/home/travis/build/npmtest/node-npmtest-newman/node_modules/newman/lib/print/index.js":"var format = require('util').format,\n    cliUtils = require('../reporters/cli/cli-utils'),\n    SPC = ' ',\n    BS = '\\b',\n    LF = '\\n',\n    WAIT_FRAMES = (/^win/).test(process.platform) ?\n        ['\\u2015', '\\\\', '|', '/'] :\n        ['⠄', '⠆', '⠇', '⠋', '⠙', '⠸', '⠰', '⠠', '⠰', '⠸', '⠙', '⠋', '⠇', '⠆'],\n    WAIT_FRAMES_SIZE = WAIT_FRAMES.length - 1,\n    WAIT_FRAMERATE = 100,\n    print;\n\n/**\n * Function that prints to stdout using standard NodeJS util.format, without end newline.\n *\n * @returns {print} - The result of context bound call to the run context, with all arguments passed.\n * @chainable\n */\nprint = function () {\n    return print.print.apply(this, arguments);\n};\n\n/**\n * Function that prints to stdout using standard NodeJS util.format, without end newline.\n *\n * @returns {print} - The updated print module wrapper, with unwait and unbuffer methods invoked.\n * @chainable\n */\nprint.print = function () {\n    print.waiting && print.unwait();\n    print._buffer && print.unbuffer();\n    process.stdout.write(format.apply(this, arguments));\n    return print;\n};\n\n/**\n * Print with a line feed at the end.\n *\n * @returns {print} - The updated print module wrapper, with unwait and unbuffer methods invoked.\n * @chainable\n */\nprint.lf = function () {\n    print.waiting && print.unwait();\n    print._buffer && print.unbuffer();\n    process.stdout.write(format.apply(this, arguments) + LF);\n    return print;\n};\n\n// store the starting frame during wait\nprint._waitPosition = 0;\n\n/**\n * Draw a spinner until next print statement is received.\n *\n * @param {Function=} color - Optional color function from `colors` module.\n * @returns {print} - The print module wrapper, with a key set as a setInterval label.\n * @chainable\n */\nprint.wait = function (color) {\n    print.unwait();\n\n    if (cliUtils.noTTY()) {\n        return print;\n    }\n\n    process.stdout.write(SPC);\n    print.waiting = setInterval(function () {\n        process.stdout.write(BS +\n            (color ? color(WAIT_FRAMES[print._waitPosition++]) : WAIT_FRAMES[print._waitPosition++]));\n        (print._waitPosition > WAIT_FRAMES_SIZE) && (print._waitPosition = 0); // move frame\n    }, WAIT_FRAMERATE);\n\n    return print;\n};\n\n/**\n * Stops a running spinner on CLI. It is automatically taken care of in most cases.\n *\n * @returns {print} - Returns the updated print module wrapper, with the cleared waiting label.\n * @chainable\n * @see print.wait\n */\nprint.unwait = function () {\n    if (print.waiting) {\n        print.waiting = clearInterval(print.waiting);\n        print._waitPosition = 0;\n        process.stdout.write('\\b');\n    }\n\n    return print;\n};\n\nprint._buffer = undefined;\n\n/**\n * Prints a message between start and end text. Consequent buffer calls does not print the start text and any other\n * unbuffered call or a delay of time prints the end text.\n *\n * @param {String} startText - The text to begin printing with.\n * @param {String} endText - The text that marks the end of the print routine.\n * @returns {print} - The update print module wrapper with internal buffer and buffering members redefined.\n * @chainable\n */\nprint.buffer = function (startText, endText) {\n    (print._buffer === undefined) && process.stdout.write(startText);\n    print._buffer = endText;\n\n    print._buferring && (print._buferring = clearTimeout(print._buferring));\n    print._buferring = setTimeout(print.unbuffer, 500);\n\n    process.stdout.write(format.apply(this, Array.prototype.splice.call(arguments, 2)));\n    return print;\n};\n\n/**\n * Prints text without flushing the buffer.\n *\n * @returns {print} - The update print module wrapper with unwait called.\n * @chainable\n * @see print.buffer\n */\nprint.nobuffer = function () {\n    print.unwait();\n    process.stdout.write(format.apply(this, arguments));\n    return print;\n};\n\n/**\n * Flushes the buffer.\n *\n * @returns {print} - The print module wrapper with internal private members: buffer, and buffering redefined.\n * @chainable\n * @see print.buffer\n */\nprint.unbuffer = function () {\n    print._buferring && (print._buferring = clearTimeout(print._buferring));\n    if (print._buffer) {\n        process.stdout.write(print._buffer);\n        print._buffer = undefined;\n    }\n    return print;\n};\n\nmodule.exports = print;\n","/home/travis/build/npmtest/node-npmtest-newman/node_modules/newman/lib/reporters/json/index.js":"var _ = require('lodash');\n\n/**\n * Reporter that simply dumps the summary object to file (default: newman-run-report.json).\n *\n * @param {Object} newman - The collection run object, with event hooks for reporting run details.\n * @param {Object} options - A set of collection run options.\n * @param {String} options.export - The path to which the summary object must be written.\n * @returns {*}\n */\nmodule.exports = function (newman, options) {\n    newman.on('beforeDone', function (err, o) {\n        newman.exports.push({\n            name: 'json-reporter',\n            default: 'newman-run-report.json',\n            path: options.export,\n            content: JSON.stringify(_.omit(o.summary, 'exports'), 0, 2)\n        });\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-newman/node_modules/newman/lib/reporters/html/index.js":"var fs = require('fs'),\n    path = require('path'),\n\n    _ = require('lodash'),\n    handlebars = require('handlebars'),\n\n    util = require('../../util'),\n\n    /**\n     * An object of the default file read preferences.\n     *\n     * @type {Object}\n     */\n    FILE_READ_OPTIONS = { encoding: 'utf8' },\n\n    /**\n     * The default Handlebars template to use when no user specified template is provided.\n     *\n     * @type {String}\n     */\n    DEFAULT_TEMPLATE = 'template-default.hbs',\n\n    /**\n     * A reference object for run stats properties to use for various assertion states.\n     *\n     * @type {Object}\n     */\n    ASSERTION_STATE = { false: 'passed', true: 'failed' },\n\n    /**\n     * The list of execution data fields that are aggregated over multiple requests for the collection run\n     *\n     * @type {String[]}\n     */\n    AGGREGATED_FIELDS = ['item', 'request', 'response'],\n\n    PostmanHTMLReporter;\n\n/**\n * A function that creates raw markup to be written to Newman HTML reports.\n *\n * @param {Object} newman - The collection run object, with a event handler setter, used to enable event wise reporting.\n * @param {Object} options - The set of HTML reporter run options.\n * @param {String=} options.template - Optional path to the custom user defined HTML report template (Handlebars).\n * @param {String=} options.export - Optional custom path to create the HTML report at.\n * @returns {*}\n */\nPostmanHTMLReporter = function (newman, options) {\n    // @todo throw error here or simply don't catch them and it will show up as warning on newman\n    var htmlTemplate = options.template || path.join(__dirname, DEFAULT_TEMPLATE),\n        compiler = handlebars.compile(fs.readFileSync(htmlTemplate, FILE_READ_OPTIONS));\n\n    newman.on('beforeDone', function () {\n        var items = {},\n            executionMeans = {},\n            netTestCounts = {},\n            aggregations = [],\n            traversedRequests = {},\n            executions = _.get(this, 'summary.run.executions'),\n            assertions = _.transform(executions, function (result, currentExecution) {\n                var reducedExecution,\n                    executionId = currentExecution.id;\n\n                if (!_.has(traversedRequests, executionId)) {\n                    // mark the current request instance as traversed\n                    _.set(traversedRequests, executionId, 1);\n\n                    // set the base assertion and cumulative test details for the current request instance\n                    _.set(result, executionId, {});\n                    _.set(netTestCounts, executionId, { passed: 0, failed: 0 });\n\n                    // set base values for overall response size and time values\n                    _.set(executionMeans, executionId, { time: { sum: 0, count: 0 }, size: { sum: 0, count: 0 } });\n\n                    reducedExecution = _.pick(currentExecution, AGGREGATED_FIELDS);\n                    reducedExecution.response = reducedExecution.response.toJSON();\n\n                    // set sample request and response details for the current request\n                    items[reducedExecution.item.id] = reducedExecution;\n                }\n\n                executionMeans[executionId].time.sum += _.get(currentExecution, 'response.responseTime', 0);\n                executionMeans[executionId].size.sum += _.get(currentExecution, 'response.responseSize', 0);\n\n                ++executionMeans[executionId].time.count;\n                ++executionMeans[executionId].size.count;\n\n                _.forEach(currentExecution.assertions, function (assertion) {\n                    var aggregationResult,\n                        assertionName = assertion.assertion,\n                        isError = _.get(assertion, 'error') !== undefined,\n                        updateKey = _.get(ASSERTION_STATE, isError);\n\n                    result[executionId][assertionName] = result[executionId][assertionName] || {\n                        name: assertionName,\n                        passed: 0,\n                        failed: 0\n                    };\n                    aggregationResult = result[executionId][assertionName];\n\n                    ++aggregationResult[updateKey];\n                    ++netTestCounts[executionId][updateKey];\n                });\n            }, {}),\n\n            aggregator = function (execution) {\n                // fetch aggregated run times and response sizes for items, (0 for failed requests)\n                var aggregationMean = executionMeans[execution.item.id],\n                    meanTime = _.get(aggregationMean, 'time', 0),\n                    meanSize = _.get(aggregationMean, 'size', 0),\n                    parent = execution.item.parent(),\n                    previous = _.last(aggregations),\n                    current = _.merge(items[execution.item.id], {\n                        assertions: _.values(assertions[execution.item.id]),\n                        mean: {\n                            time: util.prettyms(meanTime.sum / meanTime.count),\n                            size: util.filesize(meanSize.sum / meanSize.count)\n                        },\n                        cumulativeTests: netTestCounts[execution.item.id]\n                    });\n\n                if (previous && parent.id === previous.parent.id) {\n                    previous.executions.push(current);\n                }\n                else {\n                    aggregations.push({\n                        parent: {\n                            id: parent.id,\n                            name: util.getFullName(parent)\n                        },\n                        executions: [current]\n                    });\n                }\n            };\n\n        _.forEach(this.summary.run.executions, aggregator);\n\n        this.exports.push({\n            name: 'html-reporter',\n            default: 'newman-run-report.html',\n            path: options.export,\n            content: compiler({\n                timestamp: Date(),\n                version: util.version,\n                aggregations: aggregations,\n                summary: {\n                    stats: this.summary.run.stats,\n                    collection: this.summary.collection,\n                    globals: _.isObject(this.summary.globals) ? this.summary.globals : undefined,\n                    environment: _.isObject(this.summary.environment) ? this.summary.environment : undefined,\n                    failures: this.summary.run.failures.length,\n                    responseTotal: util.filesize(this.summary.run.transfers.responseTotal),\n                    responseAverage: util.prettyms(this.summary.run.timings.responseAverage),\n                    duration: util.prettyms(this.summary.run.timings.completed - this.summary.run.timings.started)\n                }\n            })\n        });\n    });\n};\n\nmodule.exports = PostmanHTMLReporter;\n","/home/travis/build/npmtest/node-npmtest-newman/node_modules/newman/lib/reporters/junit/index.js":"var _ = require('lodash'),\n    xml = require('xmlbuilder'),\n\n    util = require('../../util'),\n    JunitReporter;\n\n/**\n * A function that creates raw XML to be written to Newman JUnit reports.\n *\n * @param {Object} newman - The collection run object, with a event handler setter, used to enable event wise reporting.\n * @param {Object} reporterOptions - A set of JUnit reporter run options.\n * @param {String=} reporterOptions.export - Optional custom path to create the XML report at.\n * @returns {*}\n */\nJunitReporter = function (newman, reporterOptions) {\n    newman.on('beforeDone', function () {\n        var report = _.get(newman, 'summary.run.executions'),\n            collection = _.get(newman, 'summary.collection'),\n            cache,\n            root;\n\n        if (!report) {\n            return;\n        }\n\n        root = xml.create('testsuites', { version: '1.0', encoding: 'UTF-8' });\n        root.att('name', collection.name);\n\n        cache = _.transform(report, function (accumulator, execution) {\n            accumulator[execution.id] = accumulator[execution.id] || [];\n            accumulator[execution.id].push(execution);\n        }, {});\n\n        _.forEach(cache, function (executions, itemId) {\n            var suite = root.ele('testsuite'),\n                currentItem,\n                tests = {},\n                errorMessages;\n\n            collection.forEachItem(function (item) {\n                (item.id === itemId) && (currentItem = item);\n            });\n\n            if (!currentItem) { return; }\n\n            suite.att('name', util.getFullName(currentItem));\n            suite.att('id', currentItem.id);\n\n            _.forEach(executions, function (execution) {\n                var iteration = execution.cursor.iteration,\n                    errored,\n                    msg = `Iteration: ${iteration}\\n`;\n\n                // Process errors\n                if (execution.requestError) {\n                    errored = true;\n                    msg += ('RequestError: ' + (execution.requestError.stack) + '\\n');\n                }\n                msg += '\\n---\\n';\n                _.forEach(['testScript', 'prerequestScript'], function (prop) {\n                    _.forEach(execution[prop], function (err) {\n                        if (err.error) {\n                            errored = true;\n                            msg = (msg + prop + 'Error: ' + err.error.stack);\n                            msg += '\\n---\\n';\n                        }\n                    });\n                });\n\n                if (errored) {\n                    errorMessages = _.isString(errorMessages) ? (errorMessages + msg) : msg;\n                }\n\n                // Process assertions\n                _.forEach(execution.assertions, function (assertion) {\n                    var name = assertion.assertion,\n                        err = assertion.error;\n                    if (err) {\n                        (_.isArray(tests[name]) ? tests[name].push(err) : (tests[name] = [err]));\n                    }\n                    else {\n                        tests[name] = [];\n                    }\n                });\n                if (execution.assertions) {\n                    suite.att('tests', execution.assertions.length);\n                }\n                else {\n                    suite.att('tests', 0);\n                }\n            });\n\n            suite.att('time', _.mean(_.map(executions, function (execution) {\n                return _.get(execution, 'response.responseTime') / 1000 || 0;\n            })));\n            errorMessages && suite.ele('error').dat(errorMessages);\n\n            _.forOwn(tests, function (failures, name) {\n                var testcase = suite.ele('testcase'),\n                    failure;\n                testcase.att('name', name);\n                if (failures && failures.length) {\n                    failure = testcase.ele('failure');\n                    failure.att('type', 'AssertionFailure');\n                    failure.dat('Failed ' + failures.length + ' times.');\n                }\n            });\n        });\n\n        newman.exports.push({\n            name: 'junit-reporter',\n            default: 'newman-run-report.xml',\n            path: reporterOptions.export,\n            content: root.end({\n                pretty: true,\n                indent: '  ',\n                newline: '\\n',\n                allowEmpty: false\n            })\n        });\n    });\n};\n\nmodule.exports = JunitReporter;\n","/home/travis/build/npmtest/node-npmtest-newman/node_modules/newman/lib/reporters/progress.js":"var progress = require('cli-progress'),\n    ProgressReporter;\n\n/**\n * Little reporter that generates a collection progress status bar on CLI.\n *\n * @param {Object} newman - A run object with event handler specification methods.\n * @param {Function} newman.on - An event setter method that provides hooks for reporting collection run progress.\n * @param {Object} reporterOptions - A set of reporter specific run options.\n * @param {Object} options - A set of generic collection run options.\n * @returns {*}\n */\nProgressReporter = function (newman, reporterOptions, options) {\n    if (options.silent || reporterOptions.silent) {\n        return;\n    }\n\n    var bar = new progress.Bar({});\n\n    newman.on('start', function (err, o) {\n        bar.start(o.cursor.length * o.cursor.cycles, 0);\n    });\n\n    newman.on('item', function () {\n        bar.increment();\n    });\n\n    newman.on('done', function () {\n        bar.stop();\n    });\n};\n\nProgressReporter.prototype.dominant = true;\nmodule.exports = ProgressReporter;\n","/home/travis/build/npmtest/node-npmtest-newman/node_modules/newman/lib/reporters/emojitrain.js":"var SmileyReporter;\n\n/**\n * Fills your collection run (read life) with a bunch of Emojis 😀.\n *\n * @param {Object} newman - The collection run object with event handling hooks to enable reporting.\n * @param {Object} reporterOptions - A set of reporter specific run options.\n * @param {Object} options - A set of generic collection run options.\n * @returns {*}\n */\nSmileyReporter = function (newman, reporterOptions, options) {\n    if (options.silent || reporterOptions.silent) {\n        return;\n    }\n\n    var fails = {},\n        noteFailure;\n\n    noteFailure = function (err, args) {\n        err && (fails[args.cursor.ref] = true);\n    };\n\n    newman.on('script', noteFailure);\n    newman.on('request', noteFailure);\n    newman.on('assertion', noteFailure);\n\n    newman.on('item', function (err, args) {\n        process.stdout.write((err || fails[args.cursor.ref]) ? '😢 ' : '😀 ');\n    });\n\n    newman.on('done', function (err) {\n        console.info((err || Object.keys(fails).length) ? ' 😭' : ' 😍');\n    });\n};\n\nSmileyReporter.prototype.dominant = true;\nmodule.exports = SmileyReporter;\n","/home/travis/build/npmtest/node-npmtest-newman/node_modules/newman/lib/version.js":"var version = require('../package').version;\n\nmodule.exports = function () {\n    console.info(version);\n};\n","/home/travis/build/npmtest/node-npmtest-newman/node_modules/newman/npm/publish-wiki.js":"#!/usr/bin/env node\n/* eslint-env node, es6 */\nrequire('shelljs/global');\nrequire('colors');\n\nvar fs = require('fs'),\n    path = require('path'),\n    async = require('async'),\n\n    WIKI_URL = 'https://github.com/postmanlabs/newman.wiki.git',\n    WIKI_GIT_PATH = path.join(__dirname, '..', '.tmp', 'github-wiki'),\n    WIKI_VERSION = exec('git describe --always').stdout;\n\nmodule.exports = function (exit) {\n\n    async.series([\n        // build the reference MD\n        require('./build-wiki'),\n\n        /**\n         * Clones the existing wiki from WIKI_URL into WIKI_GIT_PATH.\n         *\n         * @param {Function} next - The callback function invoked ot mark the end of the wiki clone routine.\n         * @returns {*}\n         */\n        function (next) {\n            console.info('Publishing wiki...'.yellow.bold);\n\n            // create a location to clone repository\n            // @todo - maybe do this outside in an os-level temp folder to avoid recursive .git\n            mkdir('-p', WIKI_GIT_PATH);\n            rm('-rf', WIKI_GIT_PATH);\n\n            // @todo: Consider navigating to WIKI_GIT_PATH, setting up a new git repo there, point the remote\n            // to WIKI_GIT_URL,\n            // @todo: and push\n            exec(`git clone ${WIKI_URL} ${WIKI_GIT_PATH} --quiet`, next);\n        },\n\n        /**\n         * Update contents of the repository.\n         *\n         * @param {Function} next - The callback function invoked to mark the completion of the wiki creation.\n         * @returns {*}\n         */\n        function (next) {\n            var source = fs.readFileSync(path.join('out', 'wiki', 'REFERENCE.md')).toString(),\n                home,\n                sidebar;\n\n            // extract sidebar from source\n            sidebar = source.replace(/<a name=\"Collection\"><\\/a>[\\s\\S]+/g, '');\n\n            // remove sidebar data from home\n            home = source.substr(sidebar.length);\n\n            // add timestamp to sidebar\n            sidebar += '\\n\\n ' + (new Date()).toUTCString();\n\n            async.each([{\n                path: path.join('.tmp', 'github-wiki', '_Sidebar.md'),\n                data: sidebar\n            }, {\n                path: path.join('.tmp', 'github-wiki', 'Home.md'),\n                data: home\n            }], function (opts, next) {\n                fs.writeFile(opts.path, opts.data, next);\n            }, next);\n        },\n\n        /**\n         * Publishes the wiki to the Git remote.\n         *\n         * @param {Function} next - The callback function invoked to mark the end of the wiki publish routine.\n         * @returns {*}\n         */\n        function (next) {\n            // silence terminal output to prevent leaking sensitive information\n            config.silent = true;\n\n            pushd(WIKI_GIT_PATH);\n            exec('git add --all');\n            exec('git commit -m \"[auto] ' + WIKI_VERSION + '\"');\n            exec('git push origin master', function (code) {\n                popd();\n                next(code);\n            });\n        }\n    ], function (code) {\n        console.info(code ? colors.red.bold('\\nwiki publish failed.') :\n            colors.green(`\\nwiki published successfully for \"${WIKI_VERSION}\".`));\n        exit(code);\n    });\n};\n\n// ensure we run this script exports if this is a direct stdin.tty run\n!module.parent && module.exports(exit);\n"}